/*********************************************************************
 *
 * Project:      LIN 2.1 driver suite
 *
 * File name:    lin_cfg.c
 *
 * Description:  configuration file for LIN 2.1 driver
 *
 * Copyright:    (c) ST Microelectronics 2009
 *
 * Target:       all
 *
 * This file was automatically generated by
 * lingen 3.5.0.STM built at 14:44:55 on May  7 2010
 * (c) 2009 by STMicroelectronics, Catania
 *
 * Not to be changed by the user!
 *
 *
 *********************************************************************/

/** \file lin_cfg.c
 */

#define LIN_CFG_C

#define LIN_CFG_C_MAJOR_VERSION          3
#define LIN_CFG_C_MINOR_VERSION          5
#define LIN_CFG_C_PATCH_VERSION          0

#define LIN_CFG_C_STM

#include "lin_cfg_types.h"
#include "lin_types.h"
#include "lin_general.h"
#include "lin_cfg.h"
#include "lin_def.h"
#include "lin_diag.h"

#include "lin_slave.h"
#include "lin_diag_slave.h"

#include "lin.h"

#include "lin_version_control.h"


/* cluster speed definition */
const l_u16      l_speed[] = {19200U,  0xFFFFU};

/* initial NAD definition */
l_u8                l_initialNad = 2;


/* configured NAD definition */
l_u8                l_configuredNad = 98;


/* product ID definition */
l_productId_t     l_productId = {15, 15, 255};


/* P2_min definition */
l_u16                l_P2_min = 50;           /* 100 msec is the default value */


/* ST_min definition */
l_u16                l_ST_min = 0;            /* 20 msec is the default value */


/* N_As_timeout definition */
l_u16                l_N_As_timeout = 1000;    /* 1000 msec is the default value */


/* N_Cr_timeout definition */
l_u16                l_N_Cr_timeout = 1000;    /* 1000 msec is the default value */




/* definition and initialization of signal array */ 

LIN_ZERO_PAGE14 l_u8    l_pFrameBuf[LIN_FRAME_BUF_SIZE] =
{
   0xf8, /* 0 : 11111000*//* start of frame CCU_2 */ 
   0xff, /* 1 : 11111111*/ 
   0x00, /* 2 : 00000000*//* start of frame CLM_1 */ 
   0x00, /* 3 : 00000000*/ 
   0x00, /* 4 : 00000000*/ 
   0x00, /* 5 : 00000000*/ 
   0x00, /* 6 : 00000000*/ 
   0x00, /* 7 : 00000000*/ 
   0x00, /* 8 : 00000000*/ 
   0x80, /* 9 : 10000000*/ 
   0x00, /* 10 : 00000000*//* start of frame SlaveResp */ 
   0x00, /* 11 : 00000000*/ 
   0x00, /* 12 : 00000000*/ 
   0x00, /* 13 : 00000000*/ 
   0x00, /* 14 : 00000000*/ 
   0x00, /* 15 : 00000000*/ 
   0x00, /* 16 : 00000000*/ 
   0x00, /* 17 : 00000000*/ 
   0x00, /* 18 : 00000000*//* start of frame MasterReq */ 
   0x00, /* 19 : 00000000*/ 
   0x00, /* 20 : 00000000*/ 
   0x00, /* 21 : 00000000*/ 
   0x00, /* 22 : 00000000*/ 
   0x00, /* 23 : 00000000*/ 
   0x00, /* 24 : 00000000*/ 
   0x00 /* 25 : 00000000*/ 
};

const l_u16 l_pMessageId[LIN_FRAME_COUNT] = 
{
  0x0011U,
  0x0020U,
  0xffffU,
  0xffffU
};


LIN_ZERO_PAGE15 l_u8 l_pFrameId[LIN_FRAME_COUNT] = 
{
  255,
  255,
  125,
  60
};


const l_u8 l_pConfigFrameOrder[LIN_FRAME_COUNT] = 
{
  1,
  2,
  0,
  0
};


/********************************************************************
 *
 * l_stateReceiveIdentifier()
 */
/** \brief state machine function
 *
 * This function handles incoming characters in state
 * RECEIVE_IDENTIFIER
 *
 * - internal function
 * - slave only
 *
 * \param ifc      interface to act upon
 * \param rxChar   the character just received
 *
 * \retval none
 *
 */
STACK void l_stateReceiveIdentifier
(
  __OPTIONAL_IFC_DEFINITION_COMMA__
  l_u8                          rxChar
)
{
  l_u8                  checksumModel = 0; /* enhanced */
  TRANSFERCTRL_BUFFER(ifc)[0] = rxChar;
  TRANSFERCTRL_BYTESSENT(ifc) = 1;
  IFCCTRL_STATE(ifc) = LIN_STATE_RECEIVE_DATA;
  switch (TRANSFERCTRL_FRAME(ifc) = (l_u16)l_getFrameIndex(rxChar))
  {
    case 0u:   /* frame CCU_2 */

      TRANSFERCTRL_BYTESTOSEND(ifc) = 4;
      return ;
      
      break;

    case 1u:   /* frame CLM_1 */

      TRANSFERCTRL_BUFFER(ifc)[1] = l_pFrameBuf[2];
      TRANSFERCTRL_BUFFER(ifc)[2] = l_pFrameBuf[3];
      TRANSFERCTRL_BUFFER(ifc)[3] = l_pFrameBuf[4];
      TRANSFERCTRL_BUFFER(ifc)[4] = l_pFrameBuf[5];
      TRANSFERCTRL_BUFFER(ifc)[5] = l_pFrameBuf[6];
      TRANSFERCTRL_BUFFER(ifc)[6] = l_pFrameBuf[7];
      TRANSFERCTRL_BUFFER(ifc)[7] = l_pFrameBuf[8];
      TRANSFERCTRL_BUFFER(ifc)[8] = l_pFrameBuf[9];
      TRANSFERCTRL_BYTESTOSEND(ifc) = 10;
      
      
      break;

    case 2u:   /* frame SlaveResp */

#ifdef LIN_INCLUDE_DIAGNOSTICS
      if ((LIN_DIAG_FLAGS(ifc) & (l_u8) LIN_DIAG_ORIGINATOR_MASK) != 0)
      {
        ld_signalTxFrameError(__OPTIONAL_IFC_PARAMETER__);
      }
      LIN_DIAG_FLAGS(ifc) &= (l_u8) ~LIN_DIAG_ORIGINATOR_MASK;
#endif /* LIN_INCLUDE_DIAGNOSTICS */

      if (LIN_TEST_CHANGED_FLAG_BYTE(2))
      {
        /* do nothing */
      }
#ifdef LIN_INCLUDE_DIAGNOSTICS
      else if ((LIN_DIAG_FLAGS(ifc) & LIN_DIAG_TX_READY_MASK) != 0)
      {
        (void) ld_composeSlaveResponse(__OPTIONAL_IFC_PARAMETER_COMMA__
          &(l_pFrameBuf[10]));
      }

#endif /* LIN_INCLUDE_DIAGNOSTICS */
      else
      {
        l_terminateTransfer(__OPTIONAL_IFC_PARAMETER__);
        return ;

      }
      TRANSFERCTRL_BUFFER(ifc)[1] = l_pFrameBuf[10];
      TRANSFERCTRL_BUFFER(ifc)[2] = l_pFrameBuf[11];
      TRANSFERCTRL_BUFFER(ifc)[3] = l_pFrameBuf[12];
      TRANSFERCTRL_BUFFER(ifc)[4] = l_pFrameBuf[13];
      TRANSFERCTRL_BUFFER(ifc)[5] = l_pFrameBuf[14];
      TRANSFERCTRL_BUFFER(ifc)[6] = l_pFrameBuf[15];
      TRANSFERCTRL_BUFFER(ifc)[7] = l_pFrameBuf[16];
      TRANSFERCTRL_BUFFER(ifc)[8] = l_pFrameBuf[17];
      checksumModel = 1; /* classic */
      TRANSFERCTRL_BYTESTOSEND(ifc) = 10;
      
      break;

    case 3u:   /* frame MasterReq */

      TRANSFERCTRL_BYTESTOSEND(ifc) = 10;
      return ;
      
      break;

    case (l_u16) LIN_INVALID_FRAME_INDEX:
    default:
      l_terminateTransfer(__OPTIONAL_IFC_PARAMETER__);
      return ;

      break;
    
  }

  /* getting means that we are about to send a frame */

#ifdef LIN_DEBUG
  /* allow application to modify send buffer */
  l_dbgSlaveSendBuffer(TRANSFERCTRL_BUFFER(ifc),TRANSFERCTRL_BYTESTOSEND(ifc));

#endif /* LIN_DEBUG */

  IFCCTRL_STATE(ifc) = LIN_STATE_SEND_DATA;
  TRANSFERCTRL_BYTESSENT(ifc)++;
  l_sendByte(__OPTIONAL_IFC_PARAMETER_COMMA__
    TRANSFERCTRL_BUFFER(ifc)[1]);

  TRANSFERCTRL_CHECKSUM(ifc) = 
    ((l_u8) (checksumModel ? 0 : TRANSFERCTRL_BUFFER(ifc)[0]));


#ifdef LIN_DEBUG
  /* allow application to modify send buffer */
  l_dbgSlaveSendBuffer(TRANSFERCTRL_BUFFER(ifc),TRANSFERCTRL_BYTESTOSEND(ifc));

#endif /* LIN_DEBUG */

  return ;

} /* end l_stateReceivedIdentifier() */


/********************************************************************
 *
 * l_stateReceiveData()
 */
/** \brief state machine function
 *
 * This function handles incoming characters in state RECEIVE_DATA
 *
 * - internal function
 * - master and slave
 * 
 * \param ifc      interface to act upon
 * \param rxChar   the character just received
 *
 * \retval none
 *
 */
STACK void l_stateReceiveData
(
  __OPTIONAL_IFC_DEFINITION_COMMA__
  l_u8                          rxChar
)
{
  l_u16                         sum;
  l_u16                         temp_sum;
  l_u8                          status = LIN_STATUS_SUCCESS;
  /* copy received byte and increase counter */
  TRANSFERCTRL_BUFFER(ifc)[(TRANSFERCTRL_BYTESSENT(ifc))] = rxChar;
  (TRANSFERCTRL_BYTESSENT(ifc))++;

  sum = (l_u16) TRANSFERCTRL_CHECKSUM(ifc) + (l_u16) rxChar;
  temp_sum = TRANSFERCTRL_CHECKSUM(ifc);
  TRANSFERCTRL_CHECKSUM(ifc) = (l_u8) (sum + (sum >> 8));
  if (TRANSFERCTRL_BYTESSENT(ifc)
    >=
    TRANSFERCTRL_BYTESTOSEND(ifc)) /* frame not complete */
  {
    l_TimerStop(__OPTIONAL_TIMER_IFC_PARAMETER__);
#ifdef LIN_DEBUG
    /* allow test application to change the receive buffer */
    l_dbgSlaveReceiveBuffer(TRANSFERCTRL_BUFFER(ifc),
       TRANSFERCTRL_BYTESSENT(ifc)); 
#endif
    switch (TRANSFERCTRL_FRAME(ifc))
    {
      case 0u: /* frame CCU_2 */
        temp_sum = temp_sum + TRANSFERCTRL_BUFFER(ifc)[0];
        temp_sum = (l_u8) (temp_sum + (temp_sum >> 8));
        if (((l_u8) (~(TRANSFERCTRL_CHECKSUM(ifc))) == TRANSFERCTRL_BUFFER(ifc)[0]) && ((l_u8) (~(temp_sum)) == rxChar))
        {
          l_pFrameBuf[0] = TRANSFERCTRL_BUFFER(ifc)[1];
          l_pFrameBuf[1] = TRANSFERCTRL_BUFFER(ifc)[2];
          /* set the rx flags for the frame */
          l_pRxFlagData[0] = 0xFF;
          /* set the changed flags for the frame */
          LIN_SET_CHANGED_FLAG_BYTE(0, (l_u8) 0xFF);

          /* handle all signals with different reference pos (maybe none)*/
        }
        else
        {
          status = LIN_STATUS_ERROR;
        } /* if (checksum ok) */
        break;

      case 3u: /* frame MasterReq */
        if (((l_u8) (~(TRANSFERCTRL_CHECKSUM(ifc))) == 0) && (((l_u8) (~(temp_sum))) == rxChar))
        {
#ifdef LIN_SLAVE_NODE
#ifdef LIN_INCLUDE_DIAGNOSTICS
          ld_requestReceived(__OPTIONAL_IFC_PARAMETER_COMMA__ &(TRANSFERCTRL_BUFFER(ifc)[1]));
#endif
#endif
          l_pFrameBuf[18] = TRANSFERCTRL_BUFFER(ifc)[1];
          l_pFrameBuf[19] = TRANSFERCTRL_BUFFER(ifc)[2];
          l_pFrameBuf[20] = TRANSFERCTRL_BUFFER(ifc)[3];
          l_pFrameBuf[21] = TRANSFERCTRL_BUFFER(ifc)[4];
          l_pFrameBuf[22] = TRANSFERCTRL_BUFFER(ifc)[5];
          l_pFrameBuf[23] = TRANSFERCTRL_BUFFER(ifc)[6];
          l_pFrameBuf[24] = TRANSFERCTRL_BUFFER(ifc)[7];
          l_pFrameBuf[25] = TRANSFERCTRL_BUFFER(ifc)[8];
          /* set the rx flags for the frame */
          l_pRxFlagData[4] = 0xFF;
          l_pRxFlagData[5] = 0xFF;
          /* set the changed flags for the frame */
          LIN_SET_CHANGED_FLAG_BYTE(3, (l_u8) 0xFF);

          /* handle all signals with different reference pos (maybe none)*/
        }
        else
        {
#ifdef LIN_INCLUDE_DIAGNOSTICS
          ld_signalRxFrameError(__OPTIONAL_IFC_PARAMETER__);
#endif /* LIN_INCLUDE_DIAGNOSTICS */

          status = LIN_STATUS_ERROR;
        } /* if (checksum ok) */
        break;

      default:
        /* should never happen */
        l_terminateTransfer(__OPTIONAL_IFC_PARAMETER__);

        return ;

    }

    if (status != 0)
    {
      l_ifcSetStatus(__OPTIONAL_IFC_PARAMETER_COMMA__
        status,
        TRANSFERCTRL_BUFFER(ifc)[0]);
    } /* if (status) */

    l_terminateTransfer(__OPTIONAL_IFC_PARAMETER__);

  } /* if (frame finished) */

  return ;

} /* end l_stateReceiveData() */


/********************************************************************
 *
 * l_stateSendData()
 */
/** \brief state machine function
 *
 * This function handles incoming characters in state SEND_DATA
 *
 * - internal function
 * - master only
 *
 * \param ifc      interface to act upon
 * \param rxChar   the character just received
 *
 * \retval none
 *
 */
STACK void l_stateSendData
(
  __OPTIONAL_IFC_DEFINITION_COMMA__
  l_u8                          rxChar
)
{
  l_u8 frameId = LIN_INVALID_PROT_ID;
  l_TimerStop(__OPTIONAL_TIMER_IFC_PARAMETER__);
  switch (TRANSFERCTRL_FRAME(ifc))
  {
    case 1u: /* frame CLM_1 */
      /* set the tx flags for the frame */
      l_pTxFlagData[1] = 0xFF;
      /* clear the changed flags for the frame */
      LIN_CLEAR_CHANGED_FLAG_BYTE(1);
      /* clear error signal for node */
      l_bool_wr_CLM_ConsoleLampModuleResponseError(0);
      frameId = l_pFrameId[1];

      break;

    case 2u: /* frame SlaveResp */
#ifdef LIN_SLAVE_NODE
#ifdef LIN_INCLUDE_DIAGNOSTICS
      ld_transmittedSlaveResponse(__OPTIONAL_IFC_PARAMETER__);
#endif /* LIN_INCLUDE_DIAGNOSTICS */
#endif /* LIN_SLAVE_NODE */

      /* set the tx flags for the frame */
      l_pTxFlagData[2] = 0xFF;
      l_pTxFlagData[3] = 0xFF;
      /* clear the changed flags for the frame */
      LIN_CLEAR_CHANGED_FLAG_BYTE(2);
      frameId = l_pFrameId[2];

      break;

    default:
      /* nothing to be done */
      break;

  } /* switch (frame index) */

  l_terminateTransfer(__OPTIONAL_IFC_PARAMETER__);
  l_ifcSetStatus(__OPTIONAL_IFC_PARAMETER_COMMA__
    LIN_STATUS_SUCCESS,
    frameId);

  return ;

} /* end l_stateSendData() */


/********************************************************************
 *
 * l_serialErrorFrameBody()
 */
/** \brief function handling serial errors
 *
 * This function handles serial errors in state RECEIVE_DATA and SEND_DATA 

 *
 * - internal function
 * - slave only
 *
 * \param ifc      interface to act upon
 * \param status   indicates whether status word shall be set
 *
 * \retval none
 *
 */
STACK void l_serialErrorFrameBody
(
  __OPTIONAL_IFC_DEFINITION_COMMA__
  l_u8                        status
)
{
  l_u16                       frame = LIN_INVALID_FRAME_INDEX;

  if (TRANSFERCTRL_FRAME(ifc) < LIN_FRAME_NR_MAX)
  {
    if (l_pFrameId[TRANSFERCTRL_FRAME(ifc)]
      !=
      TRANSFERCTRL_BUFFER(ifc)[0])
    {
      frame = l_getFrameIndex(__OPTIONAL_IFC_PARAMETER_COMMA__
        TRANSFERCTRL_BUFFER(ifc)[0]);
    }
    else
    {
      frame = TRANSFERCTRL_FRAME(ifc);
    }

    switch (frame)
    {
      case (l_u16) LIN_INVALID_FRAME_INDEX:
        status = 0; /* no error reporting */
        break;

#ifdef LIN_INCLUDE_DIAGNOSTICS
      case 3u: /* MasterReq frame */
        ld_signalRxFrameError(__OPTIONAL_IFC_PARAMETER__);
        break;
#endif /* LIN_INCLUDE_DIAGNOSTICS */

#ifdef LIN_INCLUDE_DIAGNOSTICS
      case 2u: /* SlaveResp frame */
        ld_signalTxFrameError(__OPTIONAL_IFC_PARAMETER__);
        break;
#endif /* LIN_INCLUDE_DIAGNOSTICS */

      default:
        /* nothing to be done here */

        break;

    } /* switch(frame) */ 

    if (status)
    {
      l_ifcSetStatus(__OPTIONAL_IFC_PARAMETER_COMMA__
        LIN_STATUS_ERROR,
        TRANSFERCTRL_BUFFER(ifc)[0]);
    }

  } /* if (valid frame index) */

  l_terminateTransfer(__OPTIONAL_IFC_PARAMETER__);

  return ;

} /* end l_serialErrorFrameBody() */


